'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var ts = require('typescript');
var path = require('path');
var fs = require('fs');

var FSTree = require("fs-tree-diff");
var BroccoliPlugin = require("broccoli-plugin");
var walkSync = require("walk-sync");
var md5Hex = require("md5-hex");
var findup = require("findup");
var getCallerFile = require("get-caller-file");
var heimdall = require("heimdalljs");

function findConfig(root) {
    return path.join(findup.sync(root, "package.json"), "tsconfig.json");
}
function readConfig(configFile) {
    var result = ts.readConfigFile(configFile, ts.sys.readFile);
    if (result.error) {
        var message = ts.flattenDiagnosticMessageText(result.error.messageText, "\n");
        throw new Error(message);
    }
    return result.config;
}
var createObject = Object.create;
function createMap() {
    var map = createObject(null);
    map["__"] = undefined;
    delete map["__"];
    return map;
}

var SourceCache = function SourceCache(inputPath, options) {
    this.inputPath = inputPath;
    this.options = options;
    this.lastTree = undefined;
    this.cache = createMap();
    this.charset = options.charset;
    this.libFileName = "/__" + ts.getDefaultLibFileName(options);
    this.libFilePath = ts.getDefaultLibFilePath(options);
};
SourceCache.prototype.updateCache = function updateCache () {
    var nextTree = FSTree.fromEntries(walkSync.entries(this.inputPath));
    var cache = this.cache;
    var lastTree = this.lastTree;
    if (lastTree) {
        lastTree.calculatePatch(nextTree).forEach(function (ref) {
                var op = ref[0];
                var path$$1 = ref[1];

            switch (op) {
                case "unlink":
                case "create":
                case "change":
                    cache["/" + path$$1] = undefined;
                    break;
            }
        });
    }
    this.lastTree = nextTree;
};
SourceCache.prototype.realPath = function realPath (fileName) {
    if (this.libFileName === fileName) {
        return this.libFilePath;
    }
    return this.inputPath + fileName;
};
SourceCache.prototype.fileExists = function fileExists (fileName) {
    return ts.sys.fileExists(this.realPath(fileName));
};
SourceCache.prototype.readFile = function readFile (fileName) {
    var ref = this;
        var cache = ref.cache;
    var content = cache[fileName];
    if (content !== undefined) {
        return content.text;
    }
    return ts.sys.readFile(this.realPath(fileName), this.charset);
};
SourceCache.prototype.getSourceFile = function getSourceFile (fileName, languageVersion, onError) {
    var ref = this;
        var cache = ref.cache;
    var sourceFile = cache[fileName];
    if (!sourceFile) {
        var text;
        try {
            text = this.readFile(fileName);
        }
        catch (e) {
            if (onError) {
                onError(e.message);
            }
            text = "";
        }
        sourceFile = cache[fileName] = ts.createSourceFile(fileName, text, languageVersion);
    }
    return sourceFile;
};

var OutputPatcher = function OutputPatcher(outputPath) {
    this.outputPath = outputPath;
    this.entries = [];
    this.contents = createMap();
    this.lastTree = undefined;
    this.isUnchanged = function (entryA, entryB) {
        if (entryA.isDirectory() && entryB.isDirectory()) {
            return true;
        }
        if (entryA.mode === entryB.mode && entryA.checksum === entryB.checksum) {
            return true;
        }
        return false;
    };
};
// relativePath should be without leading '/' and use forward slashes
OutputPatcher.prototype.add = function add (relativePath, content) {
    this.entries.push(new Entry(this.outputPath, relativePath, md5Hex(content)));
    this.contents[relativePath] = content;
};
OutputPatcher.prototype.patch = function patch () {
    try {
        this.lastTree = this._patch();
    }
    catch (e) {
        // walkSync(output);
        this.lastTree = undefined;
        throw e;
    }
    finally {
        this.entries = [];
        this.contents = Object.create(null);
    }
};
OutputPatcher.prototype._patch = function _patch () {
    var ref = this;
        var entries = ref.entries;
        var lastTree = ref.lastTree;
        var isUnchanged = ref.isUnchanged;
        var outputPath = ref.outputPath;
        var contents = ref.contents;
    var nextTree = FSTree.fromEntries(entries, {
        sortAndExpand: true
    });
    if (!lastTree) {
        lastTree = FSTree.fromEntries(walkSync.entries(outputPath));
    }
    var patch = lastTree.calculatePatch(nextTree, isUnchanged);
    patch.forEach(function (ref) {
            var op = ref[0];
            var path$$1 = ref[1];
            var entry = ref[2];

        switch (op) {
            case "mkdir":
                // the expanded dirs don't have a base
                fs.mkdirSync(outputPath + "/" + path$$1);
                break;
            case "rmdir":
                // the expanded dirs don't have a base
                fs.rmdirSync(outputPath + "/" + path$$1);
                break;
            case "unlink":
                fs.unlinkSync(entry.fullPath);
                break;
            case "create":
            case "change":
                fs.writeFileSync(entry.fullPath, contents[path$$1]);
                break;
        }
    });
    return nextTree;
};

var Entry = function Entry(basePath, relativePath, checksum) {
    this.basePath = basePath;
    this.relativePath = relativePath;
    this.checksum = checksum;
    this.mode = 0;
    this.size = 0;
    this.mtime = new Date();
    this.fullPath = basePath + "/" + relativePath;
    this.checksum = checksum;
};
Entry.prototype.isDirectory = function isDirectory () {
    return false;
};

var sys$1 = ts.sys;
var Compiler = function Compiler(outputPath, inputPath, rawConfig, configFileName) {
    this.outputPath = outputPath;
    this.inputPath = inputPath;
    this.rawConfig = rawConfig;
    this.configFileName = configFileName;
    var output = new OutputPatcher(outputPath);
    var config = parseConfig(inputPath, rawConfig, configFileName, undefined);
    logDiagnostics(config.errors);
    var input = new SourceCache(inputPath, config.options);
    var host = createCompilerHost(input, output, config.options);
    this.output = output;
    this.config = config;
    this.input = input;
    this.host = host;
};
Compiler.prototype.updateInput = function updateInput (inputPath) {
    // the config builds the list of files
    var token = heimdall.start("TypeScript:updateInput");
    var config = this.config = parseConfig(inputPath, this.rawConfig, this.configFileName, this.config.options);
    logDiagnostics(config.errors);
    if (this.inputPath !== inputPath) {
        this.inputPath = inputPath;
        this.config = config;
        this.input = new SourceCache(inputPath, config.options);
        this.host = createCompilerHost(this.input, this.output, config.options);
    }
    else {
        this.input.updateCache();
    }
    heimdall.stop(token);
};
Compiler.prototype.compile = function compile () {
    this.createProgram();
    this.emitDiagnostics();
    this.emitProgram();
    this.patchOutput();
};
Compiler.prototype.createProgram = function createProgram () {
    var ref = this;
        var config = ref.config;
        var host = ref.host;
    var fileNames = config.fileNames;
        var options = config.options;
    var token = heimdall.start("TypeScript:createProgram");
    var program = ts.createProgram(fileNames, options, host, this.program);
    this.program = program;
    heimdall.stop(token);
};
Compiler.prototype.emitDiagnostics = function emitDiagnostics () {
    // this is where bindings are resolved and typechecking is done
    var token = heimdall.start("TypeScript:emitDiagnostics");
    var diagnostics = ts.getPreEmitDiagnostics(this.program);
    logDiagnostics(diagnostics);
    heimdall.stop(token);
};
Compiler.prototype.emitProgram = function emitProgram () {
    var token = heimdall.start("TypeScript:emitProgram");
    var emitResult = this.program.emit();
    logDiagnostics(emitResult.diagnostics);
    heimdall.stop(token);
};
Compiler.prototype.patchOutput = function patchOutput () {
    var token = heimdall.start("TypeScript:patchOutput");
    this.output.patch();
    heimdall.stop(token);
};

function logDiagnostics(diagnostics) {
    if (!diagnostics)
        { return; }
    for (var i = 0; i < diagnostics.length; i++) {
        var diagnostic = diagnostics[i];
        var message = formatDiagnostic(diagnostic);
        console.error(message);
    }
}
function formatDiagnostic(d) {
    var msg = ts.flattenDiagnosticMessageText(d.messageText, sys$1.newLine);
    if (!d.file)
        { return msg; }
    return formatMessage(d.file, d.start, msg);
}
function formatMessage(sourceFile, start, msg) {
    var loc = sourceFile.getLineAndCharacterOfPosition(start);
    return ((sourceFile.fileName) + "(" + (loc.line + 1) + "," + (loc.character + 1) + "): " + msg);
}
function parseConfig(inputPath, rawConfig, configFileName, previous) {
    var host = createParseConfigHost(inputPath);
    return ts.parseJsonConfigFileContent(rawConfig, host, "/", previous, configFileName);
}
function createParseConfigHost(inputPath) {
    var rootLength = inputPath.length;
    var stripRoot = function (fileName) { return fileName.slice(rootLength); };
    var realPath = function (fileName) { return inputPath + fileName; };
    return {
        useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames,
        fileExists: function (path$$1) { return sys$1.fileExists(realPath(path$$1)); },
        readDirectory: function (rootDir, extensions, excludes, includes) { return sys$1.readDirectory(realPath(rootDir), extensions, excludes, includes).map(stripRoot); }
    };
}
function createCompilerHost(input, output, options) {
    var newLine = getNewLine(options);
    var caseSensitive = ts.sys.useCaseSensitiveFileNames;
    return {
        getCurrentDirectory: function () { return "/"; },
        getNewLine: function () { return newLine; },
        useCaseSensitiveFileNames: function () { return caseSensitive; },
        getCanonicalFileName: function (fileName) { return caseSensitive ? fileName : fileName.toLowerCase(); },
        getSourceFile: function (fileName, languageVersion, onError) { return input.getSourceFile(fileName, languageVersion, onError); },
        getDefaultLibFileName: function () { return input.libFileName; },
        getDirectories: function (path$$1) { return ts.sys.getDirectories(input.realPath(path$$1)); },
        fileExists: function (fileName) { return input.fileExists(fileName); },
        readFile: function (fileName) { return input.readFile(fileName); },
        writeFile: function (fileName, content) {
            var relativePath = fileName.slice(1);
            output.add(relativePath, content);
        }
    };
}
function getNewLine(options) {
    var newLine;
    if (options.newLine === undefined) {
        newLine = sys$1.newLine;
    }
    else {
        newLine = options.newLine === ts.NewLineKind.LineFeed ? "\n" : "\r\n";
    }
    return newLine;
}

var TypeScript = (function (BroccoliPlugin$$1) {
    function TypeScript(inputTree, options) {
        BroccoliPlugin$$1.call(this, [inputTree], {
            name: "broccoli-typescript-compiler",
            persistentOutput: true,
            annotation: options && options.annotation
        });
        var configFileName;
        var config;
        if (!options || !options.tsconfig) {
            configFileName = findConfig(getCallerFile(2));
            config = readConfig(configFileName);
        }
        else if (typeof options.tsconfig === "string") {
            configFileName = options.tsconfig;
            config = readConfig(configFileName);
        }
        else {
            configFileName = undefined;
            config = options.tsconfig;
        }
        this.config = config;
        this.configFileName = configFileName;
    }

    if ( BroccoliPlugin$$1 ) TypeScript.__proto__ = BroccoliPlugin$$1;
    TypeScript.prototype = Object.create( BroccoliPlugin$$1 && BroccoliPlugin$$1.prototype );
    TypeScript.prototype.constructor = TypeScript;
    TypeScript.prototype.build = function build () {
        var token = heimdall.start("TypeScript:compile");
        var inputPath = this.inputPaths[0];
        var ref = this;
        var host = ref.host;
        if (!host) {
            host = this.host = new Compiler(this.outputPath, inputPath, this.config, this.configFileName);
        }
        else {
            host.updateInput(inputPath);
        }
        host.compile();
        heimdall.stop(token);
    };

    return TypeScript;
}(BroccoliPlugin));

exports.TypeScript = TypeScript;
exports.findConfig = findConfig;
//# sourceMappingURL=plugin.js.map
